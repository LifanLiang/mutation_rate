---
title: "Mutation type specific overdispersion"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: false
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(RColorBrewer)
```

### Problem overview
For the $i$th window with a certain size in the genome, we assume the observed mutation rates ($y_i$) and expected mutation rates ($mu_i$) were generated with the probababilistic model below:
$$
y_i \sim Poisson(\mu_i\theta_i)
$$
$$
\theta_i \sim Gamma(\alpha,\alpha) 
$$


### MLE of overdispersion ($\alpha$)
Integrate out $\theta_i$
$$
P(y_i | \mu_i, \alpha) = \int_0^{+\infty}  P(y_i|\mu_i,\theta_i)P(\theta_i|\alpha) \,d\theta_i
=\dfrac{\mu_i^{y_i} \alpha^\alpha}{y_i!\Gamma(\alpha)}\int_0^{+\infty} \theta_i^{y_i+\alpha-1}e^{-(\mu_i+\alpha)\theta_i}\,d\theta_i
$$
The integral part is the same as the kernel of $\theta_i\sim Gamma(y_i+\alpha, \mu_i+\alpha)$. Thus we got
$$
P(y_i | \mu_i, \alpha)=\dfrac{\mu_i^{y_i} \alpha^\alpha}{y_i!\Gamma(\alpha)}\cdot \dfrac{\Gamma(y_i+\alpha)}{(\mu_i+\alpha)^{y_i+\alpha}}
$$
The loglikelihood would be:
$$
\ell(\alpha;y_i,\mu_i) \propto log(\dfrac{\Gamma(y_i+\alpha)}{\Gamma(\alpha)})-y_ilog(\mu_i+\alpha)-\alpha log(1+\mu_i/\alpha)
$$
Considering the sparsity and the large sample size (3e10/window_size), we can further simplify the computation by isolating the scenario where $y_i=0$.
When $y_i=0,\mu_i=0$, $LL$ can be ignored:
$$
\ell(\alpha;y_i,\mu_i) = const
$$
When $y_i=0,\mu_i>0$:
$$
\ell(\alpha;y_i,\mu_i) \propto -\alpha log(1+\mu_i/\alpha)
$$

### Validation of the estimator
optim with "BFGS" method was used for MLE of overdispersion. I recomputed $\alpha$ for 5k window mutation rates. Estimated $\alpha$ is 2.709, close to the values in the proposal.

### Asymptotic normality of MLE
The second derivative of $\ell(\alpha;y_i,\mu_i)$ is
$$
\frac{d^2}{d\alpha^2}\ell(\alpha;y_i,\mu_i)=\sum_{k=1}^{y_i}\frac{-1}{(\alpha+k)^2}+\frac{y_i}{(\mu_i+\alpha)^2}+\frac{1}{\alpha}-\frac{\mu_i}{(\alpha+\mu_i)^2}-\frac{1}{\alpha+\mu_i}
$$
We used $\frac{d^2}{d\alpha^2}\ell(\alpha;y_i,\mu_i)$ to estimate the standard deviation of $\alpha$.

### Estimating $\alpha$ for different mutation types
* Results here are based on _100 bp_ window size
```{r, echo=F}
alpha.100 <- read.table("data/mute_type_100_alpha.txt", header=T)
knitr::kable(alpha.100)
```

The plot of the gamma distribution. "C_to_A.CpG" and "C_to_G.CpG" are too close to seperate.
```{r, echo=F}
gamma.pdf <- data.frame(x=1:300/100)
plot(NULL, xlim=c(0,2), ylim=c(0,6), ylab="pdf", xlab="theta")
for (i in 1:nrow(alpha.100)) {
  gamma.pdf[alpha.100[i,1]] <- dgamma(gamma.pdf$x, alpha.100[i,2], alpha.100[i,2])
  lines(gamma.pdf$x, gamma.pdf[alpha.100[i,1]][[1]], col=i)
}
legend(1.25,6, legend = alpha.100[,1], col=1:9, lty=1)
```

### Aggregate 100 bp to estimate $\alpha$ for 5K bps
```{r, echo=F}
alpha.5k <- read.table("data/mute_type_5k_alpha.txt", header=T)
ind.A <- startsWith(alpha.5k$mut_type, "A")
ind.C <- !ind.A
alpha.5k$mut_type[ind.A] <- substr(alpha.5k$mut_type[ind.A], 1, unlist(gregexec("_and",alpha.5k$mut_type[ind.A]))-1)
alpha.5k$mut_type[ind.C] <- substr(alpha.5k$mut_type[ind.C], 1, unlist(gregexec("_5k",alpha.5k$mut_type[ind.C]))-1)
knitr::kable(alpha.5k, digits=2)
```

```{r, echo=F}
gamma.pdf <- data.frame(x=1:300/100)
plot(NULL, xlim=c(0,3), ylim=c(0,4), ylab="pdf", xlab="theta")
for (i in 1:nrow(alpha.5k)) {
  gamma.pdf[alpha.5k[i,1]] <- dgamma(gamma.pdf$x, alpha.5k[i,2], alpha.5k[i,2])
  lines(gamma.pdf$x, gamma.pdf[alpha.5k[i,1]][[1]], col=i)
}
legend(1.7, 4, legend = alpha.5k[,1], col=1:9, lty=1)
```

### Observed rates vs. expected rates
#### Correlation at 5kb level
The correlation between expected rates and observed rates is probably weak. This is consistent across mutation types (the figure on the top) and the total rate counts (the bottom figure).
![](assets/exp_vs_obs_mut_type.png)
![](assets/exp_vs_obs_total.png)

#### Correlation at chromosome level
There is strong correlation when the mutation counts are summed up to the chromosome level.
![](assets/exp_vs_obs_chr_level.png)

#### Total counts for each mutation type
The total counts are also quite close between observed and expected.
```{r, echo=F}
table <- read.csv2("data/mut_count_total.csv", sep=",")
names(table) <- c("mutation type", "observed counts", "expected counts")
knitr::kable(table, digits = 1)
```
![](assets/mut_type_total.png)


### Definition of hotspots
$\ell(\alpha;y_i,\mu_i)$ is actually the normalization factor for $P(\theta|y_i,\mu_i,\alpha)$, the posterior $theta$ is $Gamma(y_i+\alpha, \mu_i+\alpha)$. Hence we have
$$
E(\theta|y_i,\mu_i,\alpha)=\frac{y_i+\alpha}{\mu_i+\alpha}
$$

Previously, I tried to define hotspots based on $E(\theta|y_i,\mu_i,\alpha)$. As shown in the figure below, large $\alpha$ in some mutation types may make it difficult to find hotspots.
![](assets/theta_post_mut_type.png)

Alternatively, we detect hotspots with a simple test. Say the null model is that:
$$
y_i \sim Poisson(\mu_i)
$$
And the alternative is that $y_i$ is not sampled from the Poisson of $\mu_i$. We used $P<0.05$ as the criteria.

### Hotspots continuity
I computed how many hotspot windows are actually adjacent to another ("continuous" column in the count table). C_to_T and A_to_G have the most hotspots.
```{r, echo=F}
table <- read.csv("data/hotspot_stats.csv",sep=",", header=1, row.names=1)
knitr::kable(table)
```

Then, we looked into the distance from each hotspot to its closest hotspot window. Hotspots in C_to_T and A_to_G have smaller distances. This result is consistent with the count table above
![](assets/hotspot_dist.png). 

### Hotspot overlap across mutation types (one 5k window away)
Here, we define the overlap as two hotspot windows are one window away. Jaccard coefficient was computed.
$$
Jaccard(A,B) = \dfrac{|A\cap B|}{|A\cup B|}
$$

```{r, echo=F, message=F}
library(rtracklayer)
library(ggplot2)
beds <- list.files("../controls_5k", full.names = T, pattern="hotspot")
bed.ranges <- list()
for (i in 1:length(beds)) {
  temp <- vroom::vroom(beds[i], col_names =T, show_col_types = F)
  bed.ranges[[i]] <- makeGRangesFromDataFrame(temp, keep.extra.columns = T, 
                                   start.field = "loc", end.field = "loc")
  start(bed.ranges[[i]]) <- start(bed.ranges[[i]]) - 1
  end(bed.ranges[[i]]) <- end(bed.ranges[[i]]) + 1
}

names <- sapply(strsplit(list.files("../controls_5k", pattern="hotspot"),"\\."), function(x) {x[1]})
names <- substr(names, 1, nchar(names)-11)
overlap <- expand.grid(x=names, y=names)
overlap$Jaccard <- 0
for (i in 1:length(beds)) {
  overlap$Jaccard[((i-1)*9+1):(i*9)] <- sapply(bed.ranges, function(x) {length(intersect(x, bed.ranges[[i]]))/length(union(x, bed.ranges[[i]]))})
  overlap$Jaccard[(i-1)*9+i] <- 0
  
}
ggplot(overlap, aes(x, y, fill= Jaccard)) + geom_tile() + theme(axis.text.x=element_text(angle = 45, hjust = 1))

```

As shown in the heatmap, A_to_G, C_to_T_CpG, and C_to_T_nonCpG share more hotspots. Hotspots in C_to_G_CpG and C_to_A_CpG are not similar to other mutation types.

```{r, echo=F, message=F}
library(ChIPpeakAnno)

res <- makeVennDiagram(Peaks=bed.ranges[c(2,8,9)], NameOfPeaks=names[c(2,8,9)], fill=c("red","blue","yellow"))
```










